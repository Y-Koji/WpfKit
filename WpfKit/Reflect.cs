using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Reflection.Emit;
using System.Security.Cryptography;
using System.Text;

namespace WpfKit
{
    public static class Reflect
    {
        private static SHA256 SHA { get; }
        private static AssemblyName AssemblyName { get; }
        private static AppDomain AppDomain { get; }
        private static AssemblyBuilder AssemblyBuilder { get; }
        public static ModuleBuilder ModuleBuilder { get; }

        private static string ASSEMBLY_NAME { get; } = "DynamicTypes";
        private static string MODULE_NAME { get; } = "AutoILGenerator";
        public static string GET_PREFIX { get; } = "get_";
        public static string SET_PREFIX { get; } = "set_";
        public static string FIELD_PREFIX { get; } = "_";

        static Reflect()
        {
            SHA = SHA256.Create();
            AssemblyName = new AssemblyName { Name = ASSEMBLY_NAME, };
            AppDomain = AppDomain.CurrentDomain;
            AssemblyBuilder = AppDomain.DefineDynamicAssembly(AssemblyName, AssemblyBuilderAccess.Run);
            ModuleBuilder = AssemblyBuilder.DefineDynamicModule(MODULE_NAME);
        }

        public static Type GetType(string dynamicName)
            => ModuleBuilder.GetType(dynamicName);

        public static string ComputeHash(string str)
            => BitConverter.ToString(SHA.ComputeHash(Encoding.UTF8.GetBytes(str)))
                .Replace("-", string.Empty).ToUpper();

        public static string TrimPrefix(string str)
            => str.Replace(GET_PREFIX, string.Empty).Replace(SET_PREFIX, string.Empty);

        public static string GetHashName(string name)
            => FIELD_PREFIX + ComputeHash(TrimPrefix(name));

        public static string GetDynamicName(object obj)
            => "AutoGenerated_" + ComputeHash(obj.GetType().FullName);

        public static EventInfo FindEvent(Type type, string eventName, Type handlerType, BindingFlags flags)
            => type.GetEvent(eventName, flags) is EventInfo @event && @event.EventHandlerType == handlerType ? @event :
                null != type.BaseType ? FindEvent(type.BaseType, eventName, handlerType, flags) :
                null;
        
        public static EventInfo FindEvent(Type type, string eventName, BindingFlags flags)
            => type.GetEvent(eventName, flags) is EventInfo @event ? @event :
                null != type.BaseType ? FindEvent(type.BaseType, eventName, flags) :
                null;

        public static FieldInfo FindField(Type type, string fieldName, Type fieldType, BindingFlags flags)
            => type.GetField(fieldName, flags) is FieldInfo field && field.FieldType == fieldType ? field :
                null != type.BaseType ? FindField(type.BaseType, fieldName, fieldType, flags) :
                null;

        public static FieldInfo FindField(Type type, string fieldName, BindingFlags flags)
            => type.GetField(fieldName, flags) is FieldInfo field ? field :
                null != type.BaseType ? FindField(type.BaseType, fieldName, flags) :
                null;
        
        public static IEnumerable<MethodInfo> GetVirtualPropertyMethods(Type type)
            => type.GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly).Where(q => q.IsVirtual)
                .Where(x => x.Name.StartsWith(GET_PREFIX) || x.Name.StartsWith(SET_PREFIX));

        public static IEnumerable<FieldBuilder> GetFieldBuilders(TypeBuilder builder, IEnumerable<MethodInfo> methods)
            => methods
                .Where(x => x.Name.StartsWith(SET_PREFIX))
                .Select(x => new { Method = x, Name = TrimPrefix(x.Name), })
                .GroupBy(x => x.Name).Select(x => new { x.First().Name, x.First().Method, })
                .Select(x => builder.DefineField(GetHashName(x.Name), x.Method.GetParameters().First().ParameterType, FieldAttributes.Public))
                .ToList();

        public static void PropertyChangedHandler(object instance, string propName)
            => (FindField(
                    instance.GetType(),
                    nameof(INotifyPropertyChanged.PropertyChanged),
                    typeof(PropertyChangedEventHandler),
                    (BindingFlags)0xFF).GetValue(instance) as PropertyChangedEventHandler)
                ?.Invoke(instance, new PropertyChangedEventArgs(propName));

        public static object WrapInstance(object value)
        {
            // ハンドリング用メソッド
            var handler =
                typeof(Reflect).GetMethod(
                nameof(PropertyChangedHandler), (BindingFlags)0xFF);

            var obj = HandleProperty(value, handler);

            CopyProperties(value, obj);

            return obj;
        }

        public static void CopyProperties(object src, object target)
        {
            if (!src.GetType().IsAssignableFrom(target.GetType()))
            {
                throw new InvalidOperationException("プロパティのコピー元とコピー先オブジェクトの型に相違があります．");
            }

            foreach (var prop in src.GetType().GetProperties())
            {
                if (null != prop.GetSetMethod())
                {
                    prop.SetValue(target, prop.GetValue(src));
                }
            }
        }

        public static object HandleProperty(object value, MethodInfo handler)
        {
            Type type = value.GetType();

            // ベース型名から派生型名を命名する
            var dynamicName = GetDynamicName(value);

            // 既に自動実装済みTypeがあればそれでインスタンスを返す
            if (GetType(dynamicName) is Type implType)
            {
                return Activator.CreateInstance(implType);
            }

            // 派生型の定義
            TypeBuilder builder = ModuleBuilder.DefineType(dynamicName, TypeAttributes.Public, type);

            // INotifyPropertyChanged が実装されていなければ実装する
            builder.AddInterfaceImplementation(typeof(INotifyPropertyChanged));
            if (null == FindEvent(type, nameof(INotifyPropertyChanged.PropertyChanged), typeof(PropertyChangedEventHandler), (BindingFlags)0xFF))
            {
                // めんでぃーからthrow
                throw new ArgumentException("INotifyPropertyChangedインターフェースが実装されていないクラスを処理しようとしました．");
            }

            // virtual メソッドのみ抽出
            var methods = GetVirtualPropertyMethods(type);

            // 各PropertyのGetter, Setter virtualメソッドをオーバーライド
            foreach (var method in methods)
            {
                var parameters = method.GetParameters().Select(q => q.ParameterType).ToArray();
                var newMethod =
                    builder.DefineMethod(method.Name,
                        MethodAttributes.Public | MethodAttributes.Virtual,
                        method.ReturnType, parameters);

                var il = newMethod.GetILGenerator();

                // 定義済みフィールドの取得
                var fieldName = GetHashName(method.Name);

                // get_PropertyName, set_PropertyNameを実装
                if (method.Name.StartsWith(GET_PREFIX))
                {
                    // base.get_[PropertyName]
                    il.Emit(OpCodes.Nop);
                    il.Emit(OpCodes.Ldarg_0);
                    il.Emit(OpCodes.Call, method);

                    il.Emit(OpCodes.Ret);
                }
                else if (method.Name.StartsWith(SET_PREFIX))
                {
                    // base.set_[PropertyName]
                    il.Emit(OpCodes.Nop);
                    il.Emit(OpCodes.Ldarg_0);
                    il.Emit(OpCodes.Ldarg_1);
                    il.Emit(OpCodes.Call, method);

                    // handler.Invoke(this, [propertyName])
                    il.Emit(OpCodes.Nop);
                    il.Emit(OpCodes.Ldarg_0);
                    il.Emit(OpCodes.Ldstr, TrimPrefix(method.Name));
                    il.Emit(OpCodes.Call, handler);
                    il.Emit(OpCodes.Nop);

                    il.Emit(OpCodes.Ret);
                }

                builder.DefineMethodOverride(newMethod, method);
            }

            builder.DefineDefaultConstructor(MethodAttributes.Public);

            object instance = Activator.CreateInstance(builder.CreateType());

            return instance;
        }
    }
}
